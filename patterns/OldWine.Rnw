\Name{Old Wine Tastes Better}

%[numeric analysis (filtering)] [generic domain]

%\todo[inline]{aka Let them mature / give 'em some time / a long future ahead / the benefit of the doubt}

\Problem
  
  Determine bug reports that are too recent to be classified.

  %Find bugs whose outcome is not yet known.
  %Discard bug reports that may have a long future ahead.
  %estao em progresso
  %nao tem finalizacao definida.
  %sao passiveis de evolucao.

\Context

  Bug reports change over time. Sometimes, one needs to classify a bug report according to the eventual occurence of some change. 
  %
  For example, suppose that one wants to predict whether a bug report will be reopened. To train a prediction model, each existing bug report has to be classified as reopening (if it was or will be reopened) or non-reopening (if it will never be reopened). However, for recent bug reports, it is likely that they were not reopened yet---even if they will be, eventually. Therefore, recent reports cannot be classified accurately with available data, and should not be used for training.
  %
  The question is how long one should wait for a change to happen (e.g., bug reopening) before assuming it will never happen.

\Solution

<<echo=false,results=hide>>=
changes <- readRDS("../data/netbeans-platform-changes.rds")
bugs <- readRDS("../data/netbeans-platform-bugs.rds")
@

  For the sake of example, consider we are studying bug reopenings. If the data shows that a bug report was reopened some day, classify it as a reopening bug. If not, then measure its lifetime, from creation to the last date available in the data. If the lifetime is long enough (i.e., it is above some \emph{threshold}), then classify it as non-reopening. That means the bug was not and, with high confidence, will never be reopened. If the lifetime is short, however, it is hard to predict whether the bug report will eventually reopen, hence discard it from the analysis.

  So, first of all, choose a threshold. Then, compute the probability that, given that a bug report did not reopen within the threshold, it will never reopen (let's call it $\alpha$, or confidence). To do that, compute the proportion of bug reports that were reopened, $r$. Then, compute the proportion of older bug reports (i.e., which have a lifetime greater than the threshold) that were not reopened within the threshold, $t$. The probability $\alpha$ can be approximated by the quotient $\frac{r}{t}$.

  Assess whether the probability $\alpha$ is high enough (most data scientists find $0.95$ to be an acceptable value). If it is not, choose another threshold and recompute $\alpha$ until you are satisfied. After finding an appropriate threshold, discard bugs with lifetime shorter than the threshold.

\Discussion

  It is a common mistake to keep recent bug reports. This is equivalent to choosing a threshold of 0, a value that is too optimistic.

\Example

  Here's how to apply this pattern using R to analyze bug reopening. First of all, create a data frame {\tt data}, augmenting {\tt bugs} with information about their first reopening and their lifetime.

<<>>=
library(data.table)
reopenings <- data.table(changes)[
  field == "bug_status" & new.value == "REOPENED",
  list(time.first.reopen = min(time)), by=bug]
data <- merge(bugs, reopenings, all.x=T)
data$days.to.reopen <- as.numeric(
  data$time.first.reopen - data$creation.time, 
  units="days")
last.time <- max(data$modif.time)
data$lifetime <- as.numeric(
  last.time - data$creation.time, 
  units="days")
@

  In this example, we use a threshold of 42 days (6 weeks). Use it to compute $\alpha$ ({\tt alpha}):

<<>>=
threshold <- 42
older <- subset(data, lifetime > threshold)
r <- sum(is.na(data$days.to.reopen)) / nrow(data)
t <- sum(is.na(older$days.to.reopen) 
  | older$days.to.reopen > threshold) / nrow(older)
alpha <- r / t
@

<<echo=false,results=hide>>=
alpha.2d <- format(round(alpha, 2), nsmall = 2)
proportion.discarded <- 1 - (nrow(older) / nrow(data))
percent.discarded <- 100 * proportion.discarded
percent.discarded <- format(round(percent.discarded, 1), nsmall = 1)
percent.discarded
@

  In this case, we find $\alpha = \Sexpr{alpha.2d}$, which is acceptable. Therefore, you should analyze only bug reports older than 42 days---which are already stored in the variable {\tt older}---and discard the rest. In this case, $\Sexpr{percent.discarded}\%$ of the bugs needed to be discarded.

% \RelatedPatterns

% Be sure to [Choose a Suitable Threshold].
