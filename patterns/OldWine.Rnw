\Name{Old Wine Tastes Better}

%[numeric analysis (filtering)] [generic domain]

%\todo[inline]{aka Let them mature / give 'em some time / a long future ahead / the benefit of the doubt}

\Problem
  
  Discard bug reports that are work in progress.

  %Find bugs whose outcome is not yet known.
  %Discard bug reports that may have a long future ahead.
  %estao em progresso
  %nao tem finalizacao definida.
  %sao passiveis de evolucao.

\Context

  Bug reports change over time. Sometimes, one needs to classify a bug report according to the eventual occurence of some change. For example, has a bug been fixed? Is this bug report a duplicate? A negative answer may turn into a positive one with the arrival of new data.

  Therefore, for recent bugs, the outcome may still be unknown. For instance, when training a model to predict which bugs get reopened and which do not, it is likely that recent bugs have not been reopened---\emph{yet}, because some of them may be in the future. The question is: how long to wait for a change to happen before assuming that it will not evenutally happen? %the bug to be reopened before classifying it as not reopened?

\Solution

<<echo=false,results=hide>>=
changes <- readRDS("../data/netbeans-platform-changes.rds")
bugs <- readRDS("../data/netbeans-platform-bugs.rds")
@

  For the sake of clarity, assume that you're interested in classifying bug reports according to whether they are eventually reopened or not. It should be easy to adapt this solution to any other outcome.

  If a bug report is reopened within the available data, classify it as reopened. If not, then consider its lifetime, from creation to the last date available in the data. If the lifetime is long enough so that reopened bugs are expected to reopen within this time (i.e., it is above some \emph{threshold}), then classify it as non-reopened. If the lifetime is short, however, it is hard to predict whether the bug report will eventually reopen, so just discard the bug from the analysis.

  So, first of all, choose a threshold. Then, compute the probability that, given that a bug report did not reopen within the threshold, it will never reopen (let's call it $\alpha$, or confidence). To do that, compute the proportion of bug reports that were reopened, $r$. Then, compute the proportion of older bug reports (i.e., which have lifetime greater than the threshold) that were not reopened within the threshold, $t$. The probability $\alpha$ can be approximated by the quotient $\sfrac{r}{t}$.

  Assess whether the probability $\alpha$ is high enough (most data scientists find $0.95$ to be an acceptable value). If it is not, choose another threshold and recompute $\alpha$ until you are satisfied. After finding an appropriate threshold, discard bugs with lifetime shorter than the threshold.

\Discussion

  It is a common mistake to keep recent temporal data in analyses. This is equivalent to choosing a threshold of 0.

\Example

  Here's how to apply this pattern using R to analyze bug reopening. First of all, create a data frame {\tt data}, augmenting {\tt bugs} with information about their first reopening and their lifetime.

<<>>=
library(data.table)
reopenings <- data.table(changes)[
  field == "bug_status" & new.value == "REOPENED",
  list(time.first.reopen = min(time)), by=bug]
data <- merge(bugs, reopenings, all.x=T)
data$days.to.reopen <- as.numeric(
  data$time.first.reopen - data$creation.time, 
  units="days")
last.time <- max(data$modif.time)
data$lifetime <- as.numeric(
  last.time - data$creation.time, 
  units="days")
@

  In this example, we use a threshold of 42 days (6 weeks). Use it to compute $\alpha$ ({\tt alpha}):

<<>>=
threshold <- 42
older <- subset(data, lifetime > threshold)
r <- sum(is.na(data$days.to.reopen)) / nrow(data)
t <- sum(is.na(older$days.to.reopen) 
  | older$days.to.reopen > threshold) / nrow(older)
alpha <- r / t
@

<<echo=false,results=hide>>=
alpha.2d <- format(round(alpha, 2), nsmall = 2)
proportion.discarded <- 1 - (nrow(older) / nrow(data))
percent.discarded <- 100 * proportion.discarded
percent.discarded <- format(round(percent.discarded, 1), nsmall = 1)
percent.discarded
@

  In this case, $\alpha = \Sexpr{alpha.2d}$, which is acceptable. Therefore, you should only keep bug reports older than 42 days---which are already stored in the variable {\tt older}---and discard the rest. In this case, only $\Sexpr{percent.discarded}\%$ of the bugs needed to be discarded.

% \RelatedPatterns

% Be sure to [Choose a Suitable Threshold].
