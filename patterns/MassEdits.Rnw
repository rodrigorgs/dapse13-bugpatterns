\Name{Look Out For Mass Edits}
% Look Out / Watch Out
% Mass Edits / Bulk Edits

\Problem

  Discover changes to bug reports that were the result of a mass edit.

\Context

  Changes to a bug report often the result of an effort made by developers to triage, fix or verify a bug. Such efforts take time. It is expected, for example, that a bug status is only changed to {\tt VERIFIED} after a developer spends some time creating test scenarios, running the software, inspecting the source code changes etc.

  However, on some bug data sets, one can find hundreds or thousands of bugs that are changed by the same developer within minutes or hours. These are mass edits and should not be interpreted as a burst of productivity. For example, if a developer changes the status of a thousand bug reports {\tt VERIFIED} within a few hours, it does not mean that he verified a thousand bugs --- that would be humanly impossible. More often than not, it just means that the repository needed some cleanup, by marking old bugs as {\tt VERIFIED} to help developers keep track of current problems.

  When analyzing bug data, mass edits should be identified and removed from the data set, as they may distort the results.

  % Sometimes lots of bug reports are updated almost at the same time. 
  % These mass edits are often a result of a cleanup due to process changes, or phase change. 
  % They should not be regarded as actual effort, because they may influence statistic analysis. 
  % For example, when many bugs are marked as VERIFIED in a short amount of time, it usually does not mean that someone actually verified that the resolution for the bug was adequate, it just means that the bug database was cleaned up.

\Solution

  Mass edits are characterized by a large number of changes of the same type (e.g., marking a bug report as {\tt VERIFIED} or changing a target milestone) made by a single developer in a short period of time. Often such changes are accompanied by a comment that is the same for all changes in the mass edit.

  There at least three solutions to find mass edits: two based on number of changes over time, and one based on developer comments. Before applying a solution, a type of change must be chosen. In the following examples, it is assumed that we are interested in mass verifications, i.e., mass edits that change a bug status to {\tt VERIFIED}, but the solutions apply to other types of change as well.

  \emph{Solution 1: Plot the accumulated number of verifications over time and look for steep ascents}. The first solution is more visual, exploratory. Select only the changes that update the bug status to verified, along with the time of the change. Sort the changes by time and then plot the accumulated number of changes over time as a line chart.

  The line is always increasing, but periods with many changes will stand out as steep ascents. Examine your vertical axis to assess whether such ascents represent a large number of changes (e.g., thousands). If this is the case, then it is likely that the changes were caused by a mass edit.

<<echo=FALSE, results=HIDE>>=
changes <- readRDS("../data/netbeans-platform-changes.rds")
@

\setkeys{Gin}{width=0.5\textwidth}

<<fig=TRUE,width=6,height=5>>=
ver <- subset(changes, field == "bug_status" 
  & new.value == "VERIFIED")
ver <- ver[order(ver$time), ]
ver$cum.changes <- 1:nrow(ver)
plot(ver$cum.changes ~ ver$time, type="l")
@

  (2) Choose a type of change you are interested

  Construct a contingency table to count how many changes 


  (3) Perform a hash of the comments (this is a optimization to avoid working with the full comments). Compute a contingency table to count, for each hash, the number of occurences per day, per developer. You can sort the hashes by
  % I only thought about this one when writing this paper

  (please note that there is a chance of hash collision, but it is unlikely, so such event, if it occurs, is probably sporadic and will not affect the analyses) 

<<>>=
#library(digest)
#comments$hash <- sapply(comments$text, digest) # or select md5() --SQL
#comments$date <- as.Date(comments$time)
#
#tab <- count(comments, c("hash", "date"))
#tab <- tab[order(tab$freq, decreasing=TRUE), ]
#head(tab)
@

  % sql: SELECT order_id,product_name,qty FROM orders INTO OUTFILE '/tmp/orders.txt'

\Discussion

  % TRADE-OFFS and COMMON MISTAKES

  %results and trade-offs of applying the pattern, common mistakes in applying the pattern to be avoided, etc.

\Example

  For example, at MSR 2012, Souza et al. \cite{Souza2012} used the first two methods. See Figure XXX in their paper for a sample visualization of



\RelatedPatterns

  Be sure to Choose a SuitableThreshold. It is also a good idea to ReadTheFineMessages

